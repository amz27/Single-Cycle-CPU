# Single-Cycle-CPU
Implemented a Single-Cycle CPU using the Xilinx design package for FPGAs for the R-type, I-type and J-type instructions
The Single-Cycle CPU has following parts of implementation:

## 1. Instruction Fetch
Instruction are stored in the instruction memory. CPU uses PC (program counter) as the address to read
an instruction from the memory as shown in Figure below. The PC will be implemented by 4 pointing to the
next instruction because an instruction has 32 bits while the PC is a byte address. The multiplexer (mux)
in the figure is used to select the next PC, which will be written to the PC at the rising edge of the clock.
![image](https://user-images.githubusercontent.com/39773496/51624536-088aed80-1f09-11e9-8d5c-389609344015.png)

## 2. Instruction Execution
After fetching the instruction, the CPU will execute it. The main components for executing an
instruction include an arithmetic logic unit (ALU), a register file and a control unit.

## 3. R-Format Instructions
Figure 1 shows the design required for executing the R-type instructions (add, sub, and, or, xor). two
source operands are read from qa and qb of the register file based on rs and rt, respectively. The two
inputs are sent to the ALU for calculation. The difference between these five instructions is only on the
ALU’s operations. A control unit generates the control signals. PC source (pcsrc) is the selection signal
of the multiplexer. ALU control (aluc) controls the operations of ALU. Write register (wreg) is a write
enable signal if wreg is ‘1’, the result calculated by the ALU will be written to the register rd of the
register file. Figure 2 shows the design required for executing the R-type instructions (sll, srl). Different
from figure 1, the input of the ALU in Figure 2 is the 5-bit shift amount (sa). The high 27 bits of ALU’s
input ‘a’ can be any value which will be ignored by the shift operations. The ‘rs’ field is not used. We
use a multiplexer to select ‘sa’ or ‘qa’ of the register file based on the instruction as shown in Figure 3.
![image](https://user-images.githubusercontent.com/39773496/51624579-248e8f00-1f09-11e9-810e-57c5ae316a96.png)

![image](https://user-images.githubusercontent.com/39773496/51624603-2f492400-1f09-11e9-9552-a6fae27e7c5d.png)

![image](https://user-images.githubusercontent.com/39773496/51624627-3a9c4f80-1f09-11e9-80bd-3ff6978f076f.png)

## 4. I-Format Instructions
The design required for executing the I-type instructions (addi, andi, ori, xori, lui, lw,
sw). the 16-bit immediate must be extended to 32 bits. The lw and sw instructions access the data
memory (Data mem component in the figure). The memory address is calculated by the ALU in the
same way as the addi instruction does. The sw instruction writes the data held in the rt register to the
data memory. For the lw instruction, the data word read from the data memory is written to the rt
register of the register file. wmem (write memory), one of the control signals generated by the control
unit, is the memory write enable signal.

## 5. Conditional Branch Instructions
The design required for executing the (be and bne) instructions. The two operands in
registers rs and rt are compared by the ALU. The result of the comparison z is sent to the control unit to
determine whether to branch or not. If the branch is taken, the 2-bit pcsrc signal will be ‘01’ to select the
branch target address. An additional 32-bit adder is used to calculate the branch target address, which is
the sum of the PC+4 (p4 in the figure) and the 2-bit left shifted sign extended immediate. These two
instructions do not write the register file (wreg = 0).

## 6. Jump Instructions
Figure below shows the design required for executing the jump instructions. This instruction uses neither the
ALU nor the register file. The jump target address is obtained by concatenation of the high 4 bits of
PC+4 and 2-bit lift-shifted ‘addr.pcsrc’ will be 11 to select the jump target address.
![image](https://user-images.githubusercontent.com/39773496/51624786-9535ab80-1f09-11e9-8014-088fc41a86d5.png)


## 7. Single-Cycle CPU
By summarizing the previous instructions, Figure 1 below shows the schematic of the single-cycle CPU plus the
instruction memory and the data memory. Putting the memory modules outside, Figure 2 shows the
single-cycle computer that consists of a single-cycle CPU and two memory modules. The reason why
we use separate instruction memory and data memory is that the single-cycle CPU completes the
execution of an instruction, including instruction fetch and data memory access, in one clock cycle. The
CPU consists of a data path and a control unit. The control unit is a component that directs the
operations of the data path.
![image](https://user-images.githubusercontent.com/39773496/51624846-b8f8f180-1f09-11e9-80bc-d4b92253cbbe.png)
![image](https://user-images.githubusercontent.com/39773496/51624849-bac2b500-1f09-11e9-9314-39ca2ce03f53.png)

```
Note: For more details, please see the `Project-write-up.docx`.
```
